" Custom keyboard shortcut

" R assignment
execute "set <M-->=\033-"
execute "set <M-m>=\033m"
inoremap <M--> <- 
inoremap <M-m> %>% 



set autoread  
au CursorHold * checktime 

syntax on
set nocp
set cursorline          " highlight current line
set lazyredraw          " redraw only when we need to.
set showmatch           " highlight matching [{()}]
set foldenable          " enable folding
set foldlevelstart=10   " open most folds by default
set autowrite           
" space open/closes folds
nnoremap <space> za     
set foldmethod=indent   " fold based on indent level

" highlight last inserted text
nnoremap gV `[v`]

" toggle gundo
nnoremap <leader>u :GundoToggle<CR>


function! NumberToggle()
    if(&relativenumber == 1)
        set norelativenumber
        set number
    else
        set relativenumber
    endif
endfunc

nnoremap <C-n> :call NumberToggle()<cr>

au FocusLost * :set number
au FocusGained * :set relativenumber

"
"Preamble
"Pathongen Infection -------------------- {{{
execute pathogen#infect()
let vimrplugin_assign = 0 " Stop annoying vimRplugin reassignment
let g:snippets_dir="$HOME/bin/util_setup/vim_setup/snippets"
" }}}

let g:solarized_termcolors=256
set background=light "Make the color suitable to dark background
colorscheme solarized

" Productivity Aliases
" HTML Tidy
 vmap ,x :!tidy -q -i --show-errors 0<CR>
"Run perlcode
 nnoremap <Leader>pl :w<CR> :!perl %<CR>
 nnoremap <Leader>cc :w<CR> :!g++ %;./a.exe<CR>
 nnoremap <Leader>py :w<CR> :!python %<CR>
 " Make executate able
 nnoremap <Leader>x :!chmod 750 %<CR>
 " reverse join
 nnoremap <Leader>j kJ

 " command mode
 " cnoremap ^ <home>
 " cnoremap $ <end>

"Align Text
 nnoremap <leader>Al :left<cr>
 nnoremap <leader>Ac :center<cr>
 nnoremap <leader>Ar :right<cr>
 vnoremap <leader>Al :left<cr>
 vnoremap <leader>Ac :center<cr>
 vnoremap <leader>Ar :right<cr>

 "Yarking
 nnoremap <silent> <F6> :YRShow<cr>


"Taglist Toggle
nnoremap <silent> <F7> :TlistToggle<CR>
"Paste Toggle
set pastetoggle=<F8>
set pastetoggle=<leader>p

"Set Methods ---------------------{{{
  set hidden "Allow modified/unsaved buffers in the background.
  set history=1000
  set nu "set number"
  set smartcase "if captial letter is used, then do not ignore case!"
  set ignorecase

  set shiftwidth=4  " size of an "indent"
  set softtabstop=4 " Indentation levels very four columns"
                    " a combination of spaces and tabs are used to simulate tab stops at a width
                    " other than the (hard)tabstop
  set expandtab     " tabs are spaces
  set tabstop=4     " size of a hard tabstop number of visual spaces per TAB



  " set textwidth=78  "Wrap at this column"


  " Search
  set incsearch           " search as characters are entered
  set hlsearch            " highlight matches
  
  runtime macros/matchit.vim
  filetype plugin indent on
  hi Comment  guifg=#80a0ff ctermfg=darkred
" }}}

"Movements--------------------------------------------------{{{
    nnoremap j gj
    nnoremap k gk
    xnoremap j gj
    xnoremap k gk
"Fasta up and down
  " nmap J 5j
    " nmap K 5k
    " xmap J 5j
    " xmap K 5k
"Split navigation
    nmap gh <C-w>h
    nmap gj <C-w>j
    nmap gk <C-w>k
    nmap gl <C-w>l
    " Allow mouse for easy resizing
    set mouse=a
    set ttymouse=xterm2
    set mouse+=a
    if &term =~ '^screen'
        " tmux knows the extended mouse mode
        set ttymouse=xterm2
    endif

"Tab navigation
    nmap <C-l> gt
    nmap <C-h> gT
    nnoremap <silent> [t :tabp<CR> 
    nnoremap <silent> ]t :tabn<CR>
    nnoremap <silent> [T :tabfirst<CR>
    nnoremap <silent> ]T :tablast<CR>
"Buffer navigation
    nnoremap <silent> [b :bprevious<CR> 
    nnoremap <silent> ]b :bnext<CR>
    nnoremap <silent> [B :bfirst<CR>
    nnoremap <silent> ]B :blast<CR>
"reselect after indenting
    vnoremap < <gv
    vnoremap > >gv
"never use Ex mode -- I never *mean* to press it
    nnoremap Q <ESC>
"Escape Mode
    imap jj <Esc>
"never use F1 -- I'm reaching for escape
    noremap  <F1> <ESC>
    noremap! <F1> <ESC>
    lnoremap <F1> <ESC>
    nnoremap aa pkj

"Ctags Tricks
    map <Leader>] :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
    map <Leader>v :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
"}}}

""Keyboard shortcuts -------------------{{{
  nmap \l :setlocal number!<CR>
  nmap \q :nohlsearch<CR>
  nmap \e :NERDTreeToggle<CR>

"insert file name : \fn in insert mode
inoremap \fn <C-R>=expand("%:t")<CR>

"Editting source files
nnoremap <Leader>ev :tabnew $MYVIMRC<CR>
nnoremap <Leader>sv :source $MYVIMRC<CR>
nnoremap <Leader>es :vsplit ~/.vim/bundle/mysnippets/snippets<CR>

"Keep search matches in the middle of the window and pulse the line when moving to them
nnoremap n nzzzv
nnoremap N Nzzzv
nnoremap vv ^vg_

"Select all
"nnoremap <C-a> ggvG
"inoremap <C-a> <Esc>ggvG

" Use sane regexes.
nnoremap / /\v
vnoremap / /\v

" Clean trailing whitespace
" nnoremap <leader>w mz:%s/\s\+$//<cr>:let @/=''<cr>`z
" " Trailing whitespace {{{
" " Only shown when not in insert mode so I don't go insane.

" augroup trailing
"     au!
"     au InsertEnter * :set listchars-=trail:‚å¥
" augroup END

" " }}}

"}}}

"set smartindent

"nnoremap <silent> <C-l> :nohl<CR><C-l>
" inoremap <F9> <C-O>za
" nnoremap <F9> za
" onoremap <F9> <C-C>za
" vnoremap <F9> zf

" Java Build
map <F9> :set makeprg=javac\ %<CR>:make<CR>
map <F10> :!echo %\|awk -F. '{print $1}'\|xargs java<CR>
map <F11> :set makeprg=javac\ #<CR>:make<CR>
map <F12> :!echo #\|awk -F. '{print $1}'\|xargs java<CR>

map! <F9> <Esc>:set makeprg=javac\ %<CR>:make<CR>
map! <F10> <Esc>:!echo %\|awk -F. '{print $1}'\|xargs java<CR>
map! <F11> <Esc>set makeprg=javac\ #<CR>:make<CR>
map! <F12> <Esc>!echo #\|awk -F. '{print $1}'\|xargs java<CR>

" Tip: load a file into the default buffer, and its driver
" into the alternate buffer, then use F9/F12 to build/run.
" Note: # (alternate filename) isn't set until you :next to it!
" Tip2: You can make then run without hitting ENTER to continue. F9-F12

" With these you can cl/cn/cp (quickfix commands) to browse the errors
" after you compile it with :make

set makeprg=javac\ %
set errorformat=%A:%f:%l:\ %m,%-Z%p^,%-C%.%#

" If two files are loaded, switch to the alternate file, then back.
" That sets # (the alternate file).
if argc() == 2
  n
  e #
endif


"focus current fold
nnoremap <leader>z zMzvzz

"Remapping marking pos
" nnoremap ' `
" nnoremap ` '
"save when losing focus
au FocusLost * :silent! wall
au FocusLost * :wa



" Make sure Vim returns to the same line when you reopen a file.
" Thanks, Amit
augroup line_return
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" }}}

"Shell command --------------------------------------------------{{{
command! -complete=shellcmd -nargs=+ Shell call s:RunShellCommand(<q-args>)
function! s:RunShellCommand(cmdline)
  echo a:cmdline
  let expanded_cmdline = a:cmdline
  for part in split(a:cmdline, ' ')
     if part[0] =~ '\v[%#<]'
        let expanded_part = fnameescape(expand(part))
        let expanded_cmdline = substitute(expanded_cmdline, part, expanded_part, '')
     endif
  endfor
  botright new
  setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
  call setline(1, 'You entered:    ' . a:cmdline)
  call setline(2, 'Expanded Form:  ' .expanded_cmdline)
  call setline(3,substitute(getline(2),'.','=','g'))
  execute '$read !'. expanded_cmdline
  setlocal nomodifiable
  1
endfunction
"}}}

function! RenameFile() "{{{
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
nnoremap <Leader>n :call RenameFile()<cr>

"}}}

function! MarkWindowSwap() "{{{
  let g:markedWinNum = winnr()
  endfunction

function! DoWindowSwap()
  "Mark destination
  let curNum = winnr()
  let curBuf = bufnr( "%" )
  exe g:markedWinNum . "wincmd w"
  "Switch to source and shuffle dest->source
  let markedBuf = bufnr( "%" )
  "Hide and open so that we aren't prompted and keep history
  exe 'hide buf' curBuf
  "Switch to dest and shuffle source->dest
  exe curNum . "wincmd w"
  "Hide and open so that we aren't prompted and keep history
  exe 'hide buf' markedBuf 			   
endfunction

nmap <silent> <leader>mw :call MarkWindowSwap()<CR>
nmap <silent> <leader>pw :call DoWindowSwap()<CR>

" Use CTRL-S for saving, also in Insert mode
noremap <C-S> :update<CR>
vnoremap <C-S> <C-C>:update<CR>
inoremap <C-S> <C-O>:update<CR>




function! HiInterestingWord(n) " {{{
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction " }}}

" Mappings {{{

nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

" }}}
" Default Highlights {{{

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195


let g:indentguides_state = 0
function! IndentGuides() " {{{
    if g:indentguides_state
        let g:indentguides_state = 0
        2match None
    else
        let g:indentguides_state = 1
        execute '2match IndentGuides /\%(\_^\s*\)\@<=\%(\%'.(0*&sw+1).'v\|\%'.(1*&sw+1).'v\|\%'.(2*&sw+1).'v\|\%'.(3*&sw+1).'v\|\%'.(4*&sw+1).'v\|\%'.(5*&sw+1).'v\|\%'.(6*&sw+1).'v\|\%'.(7*&sw+1).'v\)\s/'
    endif
endfunction " }}}
hi def IndentGuides guibg=#303030 ctermbg=234
nnoremap <leader>I :call IndentGuides()<cr>

"""""""""""""""""
" Ack motions {{{

" Motions to Ack for things.  Works with pretty much everything, including:
"
"   w, W, e, E, b, B, t*, f*, i*, a*, and custom text objects
"
" Awesome.
"
" Note: If the text covered by a motion contains a newline it won't work.  Ack
" searches line-by-line.

nnoremap <silent> <leader>A :set opfunc=<SID>AckMotion<CR>g@
xnoremap <silent> <leader>A :<C-U>call <SID>AckMotion(visualmode())<CR>

"nnoremap <bs> :Ack! '\b<c-r><c-w>\b'<cr>
"xnoremap <silent> <bs> :<C-U>call <SID>AckMotion(visualmode())<CR>

function! s:CopyMotionForType(type)
    if a:type ==# 'v'
        silent execute "normal! `<" . a:type . "`>y"
    elseif a:type ==# 'char'
        silent execute "normal! `[v`]y"
    endif
endfunction

" function! s:AckMotion(type) abort
"     let reg_save = @@

"     call s:CopyMotionForType(a:type)

"     execute "normal! :Ack! --literal " . shellescape(@@) . "\<cr>"

"     let @@ = reg_save
" endfunction

" check file change every 4 seconds ('CursorHold') and reload the buffer upon detecting change
au CursorHold * checktime  

"Ultistnip
let g:UltiSnipsExpandTrigger="<S-tab>"
" let g:UltiSnipsJumpForwardTrigger="<c-j>"
" let g:UltiSnipsJumpBackwardTrigger="<c-k>"
" 
" " If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"
let g:UltiSnipsNoPythonWarning = 1
let g:UltiSnipsSnippetsDir="~/.vim/bundle/mysnippets/snippets/"

" Useful hotkeys

nnoremap <Leader>gi :e ./.gitignore<CR>
nnoremap <Leader>btt :bufdo tab split<CR>
nnoremap <Leader>tc :tabclose<CR>
nnoremap <Leader>ls :ls<CR>

" Open markdown
nnoremap <Leader>md :w<CR> :!cygstart %<CR>

" Bash alias shortcut
nnoremap <Leader>bas :tabnew $HOME/.dotfiles/bash/share/bash_aliases_share<CR>
nnoremap <Leader>bcs :tabnew $HOME/.dotfiles/bash/share/bash_colors_share<CR>
nnoremap <Leader>bfs :tabnew $HOME/.dotfiles/bash/share/bash_functions_share<CR>
nnoremap <Leader>bss :tabnew $HOME/.dotfiles/bash/share/bash_settings_share<CR>
nnoremap <Leader>bal :tabnew $HOME/.dotfiles/bash/local/bash_aliases_local<CR>
nnoremap <Leader>bpl :tabnew $HOME/.dotfiles/bash/local/bash_paths_local<CR>
nnoremap <Leader>bsl :tabnew $HOME/.dotfiles/bash/local/bash_settings_local<CR>

" <Leader>f{char} to move to {char}
map  <Leader>f <Plug>(easymotion-bd-f)
nmap <Leader>f <Plug>(easymotion-overwin-f)

" s{char}{char} to move to {char}{char}
nmap s <Plug>(easymotion-overwin-f2)

" Move to line
map <Leader>L <Plug>(easymotion-bd-jk)
nmap <Leader>L <Plug>(easymotion-overwin-line)

" Move to word
map  <Leader>w <Plug>(easymotion-bd-w)
nmap <Leader>w <Plug>(easymotion-overwin-w)

"airline support
let g:airline#extensions#tabline#enabled = 1



"crontab stuff
if $VIM_CRONTAB == "true"
    set nobackup
    set nowritebackup
endif

"Golang
let g:go_fmt_command = "goimports"

if executable('ag')
  let g:ackprg = 'ag --vimgrep'
endif

" NERDTreee
let NERDTreeIgnore = ['\.pyc$', 'db.sqlite3']


" CtrlP
let g:ctrlp_custom_ignore = {
  \ 'file':  '\v\.pyc',
  \ }

" Tagbar
nmap <F8> :TagbarToggle<CR>

" Fugitive
"  - blame
nnoremap <leader>b :Gblame<CR>

"  - diff 
command Greview :Git! diff --staged
nnoremap <leader>r :Greview<cr>

"  - status
" Obtained from https://gist.github.com/actionshrimp/6493611
function! ToggleGStatus()
    if buflisted(bufname('.git/index'))
        bd .git/index
    else
        Gstatus
    endif
endfunction
command ToggleGStatus :call ToggleGStatus()
nnoremap <leader>s :ToggleGStatus<CR>

" Copy and Paste : https://vi.stackexchange.com/questions/84/how-can-i-copy-text-to-the-system-clipboard-from-vim
noremap <Leader>y "*y
noremap <Leader>Y "+y
"noremap <Leader>p "*p
"noremap <Leader>P "+p

" Autopair
let g:AutoPairsShortcutToggle = '<Leader>m'


" Spell file
set spelllang=en
set spellfile=$HOME/.dotfiles/vim/spell/en.utf-8.add
set spell
nnoremap <Leader>sp :e $HOME/.dotfiles/vim/spell/en.utf-8.add<CR>
nnoremap <Leader>ssp :mkspell! $HOME/.dotfiles/vim/spell/en.utf-8.add<CR>
