#synonsis
# calculator
# extract
# cd_func
# fwak
# up
# wiki
# marks


# This function is to be used in PS1
# example:  PS1="\e[1;31m[\!][\d,\@] \u@\[\033]0;\h:\W\007\]\h: \w]  \$(parse_git_branch)\e[m\n  \[\e]0;ibm\a\] ===> "
function parse_git_branch {
   git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
}


# calculator
calc() { 
  echo $@| tr -d ',' | perl -ne 'print eval . "\n"'
}

# b) function cd_func
# This function defines a 'cd' replacement function capable of keeping, 
# displaying and accessing history of visited directories, up to 10 entries.
# To use it, uncomment it, source this file and try 'cd --'.
# acd_func 1.0.5, 10-nov-2004
# Petar Marinov, http:/geocities.com/h2428, this is public domain
cd_func ()
{
  local x2 the_new_dir adir index
  local -i cnt

  if [[ $1 ==  "--" ]]; then
    dirs -v
    return 0
  fi

  the_new_dir=$1
  [[ -z $1 ]] && the_new_dir=$HOME

  if [[ ${the_new_dir:0:1} == '-' ]]; then
    #
    # Extract dir N from dirs
    index=${the_new_dir:1}
    [[ -z $index ]] && index=1
    adir=$(dirs +$index)
    [[ -z $adir ]] && return 1
    the_new_dir=$adir
  fi

  #
  # '~' has to be substituted by ${HOME}
  [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

  #
  # Now change to the new dir and add to the top of the stack
  pushd "${the_new_dir}" > /dev/null
  [[ $? -ne 0 ]] && return 1
  the_new_dir=$(pwd)

  #
  # Trim down everything beyond 11th entry
  popd -n +11 2>/dev/null 1>/dev/null

  #
  # Remove any other occurence of this dir, skipping the top of the stack
  for ((cnt=1; cnt <= 10; cnt++)); do
    x2=$(dirs +${cnt} 2>/dev/null)
    [[ $? -ne 0 ]] && return 0
    [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
    if [[ "${x2}" == "${the_new_dir}" ]]; then
      popd -n +$cnt 2>/dev/null 1>/dev/null
      cnt=cnt-1
    fi
  done

  return 0
}

cd_func_decorated() {
  cd_func "$1"
  if [[ "$1" != "--" ]]; then
    ls -Xlhp --group-directories-first
    git status -s 2> /dev/null
  fi

}
alias cd=cd_func_decorated


cdf () {
    cd $(dirname "$1")
}

#--------------------------------------------------
extract () {
   if [ -f $1 ] ; then
       case $1 in
           *.tar.bz2)   tar xvjf $1    ;;
           *.tar.gz)    tar xvzf $1    ;;
           *.bz2)       bunzip2 $1     ;;
           *.rar)       unrar x $1       ;;
           *.gz)        gunzip $1      ;;
           *.tar)       tar xvf $1     ;;
           *.tbz2)      tar xvjf $1    ;;
           *.tgz)       tar xvzf $1    ;;
           *.zip)       unzip $1       ;;
           *.Z)         uncompress $1  ;;
           *.7z)        7z x $1        ;;
           *)           echo "don't know how to extract '$1'..." ;;
       esac
   else
       echo "'$1' is not a valid file!"
   fi
 }

#fawk
 function fawk {
      first="awk '{print "
          last="}'"
              cmd="${first}\$${1}${last}"
                  eval $cmd
}

#up
up(){
    local d=""
      limit=$1
        for ((i=1 ; i <= limit ; i++))
              do
                      d=$d/..
                          done
                            d=$(echo $d | sed 's/^\///')
                              if [ -z "$d" ]; then
                                    d=..
                                      fi
                                        cd $d
}

#wiki
wiki() { dig +short txt $1.wp.dg.cx; }


 # a) function settitle
settitle () 
 { 
 echo -ne "\e]2;$@\a\e]1;$@\a"; 
}
#ls what is most relevant right now
function lt() { ls -ltrsa "$@" | tail; }
#useful find name
function fname() { find . -iname "*$@*"; }

#psgrep
function psgrep() { ps axuf | grep -v grep | grep "$@" -i --color=auto; }

#qsub
# #function qs {
#     mem=$1; shift
#     hours=$1; shift
#     message=$(qsub -l mem=${mem}G,time=${hours}:: "$@")
#     echo $message
#     jid=$( echo $message | cut -f3 -d" " )
# }
function bs {
    mem=$1; shift
    hours=$1; shift
    message=$(qsub -b y -j n -l mem=${mem}G,time=${hours}:: "$@")
    echo $message
    jid=$( echo $message | cut -f3 -d" " )
}
function qsm {
    mem=$1; shift
    hours=$1; shift
    message=$(qsub -m ea -l mem=${mem}G,time=${hours}:: "$@")
    echo $message
    echo "Email will be sent"
    jid=$( echo $message | cut -f3 -d" " )
}
function bsm {
    mem=$1; shift
    hours=$1; shift
    message=$(qsub -m ea -b y -j n -l mem=${mem}G,time=${hours}:: "$@")
    echo $message
    echo "Email will be sent"
    jid=$( echo $message | cut -f3 -d" " )
}

# vim()
# {
#     local STTYOPTS="$(stty --save)"
#     stty stop '' -ixoff
#     command vim "$@"
#     stty "$STTYOPTS"
# }

export MARKPATH=$HOME/.marks
function jump { 
    unjump_dir=$(pwd)
    cd $MARKPATH/$1 2>/dev/null || echo "No such mark: $1"
    cd $(readlink -m $(pwd))
    ls -lh
}

function unjump {
    if [[ -z $unjump_dir ]]; then
	echo "There is nowhere to un'jump to!"
    else
	cd $unjump_dir
	ls -lh
    fi
}
function mark { 
    mkdir -p $MARKPATH; ln -sf $(pwd) $MARKPATH/$1
}
function unmark { 
    rm -i $MARKPATH/$1 
}
function marks {
    ls -l $MARKPATH | sed 's/  / /g' | cut -d' ' -f9- | sed 's/ -/\t-/g' && echo
}



colors() {
    local fgc bgc vals seq0

    printf "Color escapes are %s\n" '\e[${value};...;${value}m'
    printf "Values 30..37 are \e[33mforeground colors\e[m\n"
    printf "Values 40..47 are \e[43mbackground colors\e[m\n"
    printf "Value  1 gives a  \e[1mbold-faced look\e[m\n\n"

    # foreground colors
    for fgc in {30..37}; do
	# background colors
	for bgc in {40..47}; do
	    fgc=${fgc#37} # white
	    bgc=${bgc#40} # black

	    vals="${fgc:+$fgc;}${bgc}"
	    vals=${vals%%;}

	    seq0="${vals:+\e[${vals}m}"
	    printf "  %-9s" "${seq0:-(default)}"
	    printf " ${seq0}TEXT\e[m"
	    printf " \e[${vals:+${vals+$vals;}}1mBOLD\e[m"
	done
	echo; echo
    done
}

# inspired by `bd`: https://github.com/vigneshwaranr/bd
function _up() {
    local rx updir
    rx=$(ruby -e "print '$1'.gsub(/\s+/,'').split('').join('.*?')")
    updir=`echo $PWD | ruby -e "print STDIN.read.sub(/(.*\/${rx}[^\/]*\/).*/i,'\1')"`
    echo -n "$updir"
}
 
function up() {
    if [ $# -eq 0 ]; then
	echo "up: traverses up the current working directory to first match and cds to it"
	echo "You need an argument"
    else
	cd $(_up "$@")
    fi
}

function history_original() {
    export HISTFILE=$HOME/.bash_history
}

function histgrep ()
{
  grep -r "$@" ~/.history
    history | grep "$@"
}
