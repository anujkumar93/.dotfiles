#synonsis
# calculator
# extract
# cd_func
# fwak
# up
# wiki
# marks



# calculator
calc(){ awk "BEGIN{ print $* }" ;}

# b) function cd_func
# This function defines a 'cd' replacement function capable of keeping, 
# displaying and accessing history of visited directories, up to 10 entries.
# To use it, uncomment it, source this file and try 'cd --'.
# acd_func 1.0.5, 10-nov-2004
# Petar Marinov, http:/geocities.com/h2428, this is public domain
cd_func ()
{
  local x2 the_new_dir adir index
  local -i cnt

  if [[ $1 ==  "--" ]]; then
    dirs -v
    return 0
  fi

  the_new_dir=$1
  [[ -z $1 ]] && the_new_dir=$HOME

  if [[ ${the_new_dir:0:1} == '-' ]]; then
    #
    # Extract dir N from dirs
    index=${the_new_dir:1}
    [[ -z $index ]] && index=1
    adir=$(dirs +$index)
    [[ -z $adir ]] && return 1
    the_new_dir=$adir
  fi

  #
  # '~' has to be substituted by ${HOME}
  [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

  #
  # Now change to the new dir and add to the top of the stack
  pushd "${the_new_dir}" > /dev/null
  [[ $? -ne 0 ]] && return 1
  the_new_dir=$(pwd)

  #
  # Trim down everything beyond 11th entry
  popd -n +11 2>/dev/null 1>/dev/null

  #
  # Remove any other occurence of this dir, skipping the top of the stack
  for ((cnt=1; cnt <= 10; cnt++)); do
    x2=$(dirs +${cnt} 2>/dev/null)
    [[ $? -ne 0 ]] && return 0
    [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
    if [[ "${x2}" == "${the_new_dir}" ]]; then
      popd -n +$cnt 2>/dev/null 1>/dev/null
      cnt=cnt-1
    fi
  done

  return 0
}

alias cd=cd_func

#--------------------------------------------------
extract () {
   if [ -f $1 ] ; then
       case $1 in
           *.tar.bz2)   tar xvjf $1    ;;
           *.tar.gz)    tar xvzf $1    ;;
           *.bz2)       bunzip2 $1     ;;
           *.rar)       unrar x $1       ;;
           *.gz)        gunzip $1      ;;
           *.tar)       tar xvf $1     ;;
           *.tbz2)      tar xvjf $1    ;;
           *.tgz)       tar xvzf $1    ;;
           *.zip)       unzip $1       ;;
           *.Z)         uncompress $1  ;;
           *.7z)        7z x $1        ;;
           *)           echo "don't know how to extract '$1'..." ;;
       esac
   else
       echo "'$1' is not a valid file!"
   fi
 }

#fawk
 function fawk {
      first="awk '{print "
          last="}'"
              cmd="${first}\$${1}${last}"
                  eval $cmd
}

#up
up(){
    local d=""
      limit=$1
        for ((i=1 ; i <= limit ; i++))
              do
                      d=$d/..
                          done
                            d=$(echo $d | sed 's/^\///')
                              if [ -z "$d" ]; then
                                    d=..
                                      fi
                                        cd $d
}

#wiki
wiki() { dig +short txt $1.wp.dg.cx; }


 # a) function settitle
settitle () 
 { 
 echo -ne "\e]2;$@\a\e]1;$@\a"; 
}
#ls what is most relevant right now
function lt() { ls -ltrsa "$@" | tail; }
#useful find name
function fname() { find . -iname "*$@*"; }

#psgrep
function psgrep() { ps axuf | grep -v grep | grep "$@" -i --color=auto; }

#qsub
# #function qs {
#     mem=$1; shift
#     hours=$1; shift
#     message=$(qsub -l mem=${mem}G,time=${hours}:: "$@")
#     echo $message
#     jid=$( echo $message | cut -f3 -d" " )
# }
function bs {
    mem=$1; shift
    hours=$1; shift
    message=$(qsub -b y -j n -l mem=${mem}G,time=${hours}:: "$@")
    echo $message
    jid=$( echo $message | cut -f3 -d" " )
}
function qsm {
    mem=$1; shift
    hours=$1; shift
    message=$(qsub -m ea -l mem=${mem}G,time=${hours}:: "$@")
    echo $message
    echo "Email will be sent"
    jid=$( echo $message | cut -f3 -d" " )
}
function bsm {
    mem=$1; shift
    hours=$1; shift
    message=$(qsub -m ea -b y -j n -l mem=${mem}G,time=${hours}:: "$@")
    echo $message
    echo "Email will be sent"
    jid=$( echo $message | cut -f3 -d" " )
}

vim()
{
    local STTYOPTS="$(stty --save)"
    stty stop '' -ixoff
    command vim "$@"
    stty "$STTYOPTS"
}

export MARKPATH=$HOME/.marks
function jump { 
    cd $MARKPATH/$1 2>/dev/null || echo "No such mark: $1"
    cd $(readlink -m $(pwd))
}
function mark { 
    mkdir -p $MARKPATH; ln -s $(pwd) $MARKPATH/$1
}
function unmark { 
    rm -i $MARKPATH/$1 
}
function marks {
    ls -l $MARKPATH | sed 's/  / /g' | cut -d' ' -f9- | sed 's/ -/\t-/g' && echo
}
